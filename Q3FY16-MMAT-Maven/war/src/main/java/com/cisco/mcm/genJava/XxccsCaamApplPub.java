/*****************************************************************************
 * XxccsCaamApplPub.java
 *
 * Copyright 2001-2003 Cisco Systems, Inc. All Rights Reserved.
 * This software is the proprietary information of  Cisco Systems, Inc.
 *
 * NOTE:
 * This file was generated by the genJava script.  Please only make
 * changes to the file within protect blocks to ensure your changes are 
 * preserved when this file is next regenerated.
 * 
 *****************************************************************************/

package com.cisco.mcm.genJava;

/* Begin generated import statements */
import java.math.BigDecimal;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import oracle.jdbc.driver.OracleResultSet;
import oracle.jdbc.driver.OracleTypes;
import oracle.sql.ARRAY;
import oracle.sql.ArrayDescriptor;
import oracle.sql.STRUCT;

import com.cisco.ca.fea.daoservices.DAOServices;
import com.cisco.ca.fea.daoservices.util.ConnectionUtil;
 


/* End generated import statements */

/* BEGIN PROTECT_BLOCK user_imports */
/* END PROTECT_BLOCK user_imports */

 


public class XxccsCaamApplPub extends Object implements java.io.Serializable {

    private static XxccsCaamApplPub theInstance=null;
    
/* BEGIN PROTECT_BLOCK user_member_variables */
/* END PROTECT_BLOCK user_member_variables */

    


/* BEGIN PROTECT_BLOCK user_public_constants */
/* END PROTECT_BLOCK user_public_constants */


/* BEGIN PROTECT_BLOCK user_static_initializers */
/* END PROTECT_BLOCK user_static_initializers */


    public static synchronized XxccsCaamApplPub getInstance() {
        if (theInstance==null) {
            theInstance = new XxccsCaamApplPub();
        }
        return theInstance;
    }
    
    private XxccsCaamApplPub() {
/* BEGIN PROTECT_BLOCK user_private_constructor */
/* END PROTECT_BLOCK user_private_constructor */

    }
    

    
    private static ARRAY buildOracleArrayFromList(Connection conn,List list,com.cisco.mcm.genJava.XxccsCaamUserAttrObjType dummy)
        throws SQLException {
       // ARRAY oracleArray=null;
        com.cisco.mcm.genJava.XxccsCaamUserAttrObjType element=null;
        Object[] jarray=null;
        STRUCT struct=null;
        ArrayDescriptor desc=
            ArrayDescriptor.createDescriptor("APPS.XXCCS_CAAM_USER_ATTR_TAB_TYPE",conn);
        int i=0;
        if (list!=null) {
            jarray=new Object[list.size()];
            Iterator iterator=list.iterator();
            while (iterator.hasNext()) {
                element=(com.cisco.mcm.genJava.XxccsCaamUserAttrObjType)iterator.next();
                struct=element.asStruct(conn);
                jarray[i++]=struct;
            }
        }
        return new ARRAY(desc,conn,jarray);
    }
    private static List buildListFromOracleArray(Connection conn,List list,ARRAY array,com.cisco.mcm.genJava.XxccsCaamUserAttrObjType dummy)
        throws SQLException,InstantiationException,IllegalAccessException {
        List rlist=null;
        com.cisco.mcm.genJava.XxccsCaamUserAttrObjType element=null;
        Object[] jarray=null;
        STRUCT struct=null;
        rlist=(list==null) ? new ArrayList() : list;
        if (list != null) {
            list.clear();
        }
        if (array!=null) {
            jarray=(Object[])array.getArray();
            for (int i=0;i<jarray.length;i++) {
                struct=(STRUCT)jarray[i];
                if (struct == null) {
                    element = null;
                } else {
                    element=com.cisco.mcm.genJava.XxccsCaamUserAttrObjType.newFromStruct(conn,struct);
                }
                rlist.add(element);
            }
        }
        return rlist;
    }

    private static List buildListFromOracleArray(Connection conn,List list,ARRAY array,com.cisco.mcm.genJava.XxccsCaamFuncaccessObjType dummy)
        throws SQLException,InstantiationException,IllegalAccessException {
        List rlist=null;
        com.cisco.mcm.genJava.XxccsCaamFuncaccessObjType element=null;
        Object[] jarray=null;
        STRUCT struct=null;
        rlist=(list==null) ? new ArrayList() : list;
        if (list != null) {
            list.clear();
        }
        if (array!=null) {
            jarray=(Object[])array.getArray();
            for (int i=0;i<jarray.length;i++) {
                struct=(STRUCT)jarray[i];
                if (struct == null) {
                    element = null;
                } else {
                    element=com.cisco.mcm.genJava.XxccsCaamFuncaccessObjType.newFromStruct(conn,struct);
                }
                rlist.add(element);
            }
        }
        return rlist;
    }

    private static List buildListFromOracleArray(Connection conn,List list,ARRAY array,com.cisco.mcm.genJava.XxccsCaamUserlistObjType dummy)
        throws SQLException,InstantiationException,IllegalAccessException {
        List rlist=null;
        com.cisco.mcm.genJava.XxccsCaamUserlistObjType element=null;
        Object[] jarray=null;
        STRUCT struct=null;
        rlist=(list==null) ? new ArrayList() : list;
        if (list != null) {
            list.clear();
        }
        if (array!=null) {
            jarray=(Object[])array.getArray();
            for (int i=0;i<jarray.length;i++) {
                struct=(STRUCT)jarray[i];
                if (struct == null) {
                    element = null;
                } else {
                    element=com.cisco.mcm.genJava.XxccsCaamUserlistObjType.newFromStruct(conn,struct);
                }
                rlist.add(element);
            }
        }
        return rlist;
    }

       
    /**
     * Returns a user id for a given username.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW
     *  ('XXCCS_CAAM_UNKNOWN_USER','XXCCS_CAAM') if no data found.
     *
     * @param userName The username of TYPE fnd_user.username.
     *
     * @return The user_id of TYPE fnd_user.user_id.
     *
     **/
    public BigDecimal getUserId(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_id(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a userid for a given user name and is NOT end dated.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW
     *  ('XXCCS_CAAM_UNKNOWN_USER','XXCCS_CAAM') if no data found.
     *
     * @param userName The user_name of TYPE fnd_user.user_name.
     * @return The user_id of TYPE fnd_user.user_id.
     *
     **/
    public BigDecimal getValidUserId(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_valid_user_id(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a username for a given userid and is NOT end dated.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW
     *  ('XXCCS_CAAM_UNKNOWN_USER','XXCCS_CAAM') if no data found.
     *
     * @param userId The user_id of TYPE fnd_user.user_id.
     * @return The user_name of TYPE fnd_user.user_name.
     *
     **/
    public String getValidUserName(
        DAOServices services,
        BigDecimal userId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_valid_user_name(:2); end;");
            stmt.setBigDecimal(2,userId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a username for a given userid. Does not check if the user is
     * end dated.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW
     *  ('XXCCS_CAAM_UNKNOWN_USER','XXCCS_CAAM') if no data found.
     *
     * @param userId The user_id of TYPE fnd_user.user_id.
     *
     * @return The user_id of TYPE fnd_user.user_name.
     *
     **/
    public String getUserName(
        DAOServices services,
        BigDecimal userId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_name(:2); end;");
            stmt.setBigDecimal(2,userId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Checks if a given user_name exists and is NOT end dated.
     * Returns FND_API.TRUE if user_name exists.
     * Else if user_name does not exist, it returns FND_API.G_FALSE.
     *
     * @param userName The user_name of TYPE fnd_user.user_name.
     *
     * @return FND_API.G_TRUE if user_name exists, else FND_API.G_FALSE
     *
     **/
    public String checkUserActive(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_active(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Checks if a given user_id exists and is NOT end dated.
     * Returns FND_API.TRUE if user_id exists.
     * Else if user_id does not exist, it returns FND_API.G_FALSE.
     *
     * @param userId The user_id of TYPE fnd_user.user_id.
     *
     * @return FND_API.G_TRUE if user_id exists, else FND_API.G_FALSE
     *
     **/
    public String checkUserActive(
        DAOServices services,
        BigDecimal userId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_active(:2); end;");
            stmt.setBigDecimal(2,userId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Checks if a given user_id exists or not. Does not check if the user is
     * end dated.
     * Returns FND_API.TRUE if user_id exists.
     * Else if user_id does not exist, it returns FND_API.G_FALSE.
     *
     * @param userId The user_id of TYPE fnd_user.user_id.
     *
     * @return FND_API.G_TRUE if user_id exists, else FND_API.G_FALSE
     *
     **/
    public String checkUserId(
        DAOServices services,
        BigDecimal userId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_id(:2); end;");
            stmt.setBigDecimal(2,userId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Checks if a given user_name exists or not. Does not check if the user is
     * end dated.
     * Returns FND_API.TRUE if user_name exists.
     * Else if user_name does not exist, it returns FND_API.G_FALSE.
     *
     * @param userName The user_name of TYPE fnd_user.user_name.
     *
     * @return FND_API.G_TRUE if user_name exists, else FND_API.G_FALSE
     *
     **/
    public String checkUserName(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_name(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns an application id for a given application name
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_APPLICATION')
     * if the given application name does not exists.
     *
     * @param applName The application_name of
     *                          TYPE fnd_application_tl.application_name.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The application_id of TYPE fnd_application_tl.application_id.
     *
     **/
    public BigDecimal getApplIdName(
        DAOServices services,
        String applName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_appl_id_name(:2,:3); end;");
            stmt.setString(2,applName);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns an application shortname for a given application name
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_APPLICATION)
     * if the given application name does not exists.
     *
     * @param applName The application_name of TYPE
     *                          fnd_application_tl.application_name.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The application short name of TYPE
     *           fnd_application.application_short_name%TYPE
     *
     **/
    public String getApplSnameName(
        DAOServices services,
        String applName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_appl_sname_name(:2,:3); end;");
            stmt.setString(2,applName);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns an application name for a given application id
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_APPLICATION'),
     * if the given application id does not exists.
     *
     * @param applId The application_id of TYPE
     *                       fnd_application_tl.application_id.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The application short name of TYPE
     *           fnd_application.application_short_name%TYPE
     *
     **/
    public String getApplNameId(
        DAOServices services,
        BigDecimal applId,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_appl_name_id(:2,:3); end;");
            stmt.setBigDecimal(2,applId);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns an application short name based on an application id.
     * If there is no application based on the provided application id
     * then an exception will be raised.
     *
     *
     * @param applId the system key representing an application
     *                    registered within Oracle 11i.
     *
     * @return a string containing the application short name assigned
     *         to a registered Oracle 11i application.
     *
     * @throws UNKNOWN_APPLICATION when an application short name can not
     *                             be found based on the application id
     *
     */
    public String getApplSnameId(
        DAOServices services,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_appl_sname_id(:2); end;");
            stmt.setBigDecimal(2,applId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns an application id based on the application short name
     * as created when registering an Oracle 11i application.
     * If no application can be found based on the application short name.
     *
     *
     * @param applSname the application short name used to identify
     *                       an application (a short cut value)
     *
     * @return a number containing the system key of a registered Oracle 11i
     *         application.
     *
     * @throws UNKNOWN_APPLICATION when an application id can not be found
     *                             based on the application short name
     *
     */
    public BigDecimal getApplIdSname(
        DAOServices services,
        String applSname)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_appl_id_sname(:2); end;");
            stmt.setString(2,applSname);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns application name based on the associated application short name
     * If no application is found based on the application short name, then
     * an exception will be raised.
     *
     *
     * @param applSname the application short name used to identify
     *                       an application (a short cut value)
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return a string containing the full application name for a registered
     *         Oracle 11i application
     *
     * @throws UNKNOWN_APPLICATION when an application name can not be found
     *                             based on the applicatoin short name
     *
     */
    public String getApplNameSname(
        DAOServices services,
        String applSname,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_appl_name_sname(:2,:3); end;");
            stmt.setString(2,applSname);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility id for a given responsibility name,
     * application_id of the responsibility
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY'),
     * if the given responsibility name does not exists.
     *
     * @param respName The responsibility name of TYPE
     *                          fnd_responsibility_tl.responsibility_name
     *
     * @param applId The application_id of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The responsibility_id of TYPE
     *           fnd_responsibility_tl.responsibility_id%TYPE
     *
     **/
    public BigDecimal getRespIdName(
        DAOServices services,
        String respName,
        BigDecimal applId,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_id_name(:2,:3,:4); end;");
            stmt.setString(2,respName);
            stmt.setBigDecimal(3,applId);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility id for a given responsibility name,
     * application name of the responsibility
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY'),
     * if the given responsibility name does not exists.
     *
     * @param respName The responsibility name of TYPE
     *                          fnd_responsibility_tl.responsibility_name
     *
     * @param applName The application_name of TYPE
     *                       fnd_application_tl.application_id.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The responsibility_id of TYPE
     *           fnd_responsibility_tl.responsibility_id%TYPE
     *
     **/
    public BigDecimal getRespIdName(
        DAOServices services,
        String respName,
        String applName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_id_name(:2,:3,:4); end;");
            stmt.setString(2,respName);
            stmt.setString(3,applName);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility name for a given responsibility id,
     * application_id of the responsibility
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY')
     * if the given responsibility id does not exists.
     *
     * @param respId The responsibility id of TYPE
     *                       fnd_responsibility_tl.responsibility_id
     *
     * @param applId The application_id of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The responsibility_name of TYPE
     *           fnd_responsibility_tl.responsibility_name%TYPE
     *
     **/
    public String getRespNameId(
        DAOServices services,
        BigDecimal respId,
        BigDecimal applId,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_name_id(:2,:3,:4); end;");
            stmt.setBigDecimal(2,respId);
            stmt.setBigDecimal(3,applId);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility name for a given responsibility key and
     * application_id combination. If a responsibility can not be found
     * based on the provided inputs, then an exception will be raised.
     *
     *
     * @param respKey The responsibility key of TYPE
     *                         fnd_responsibility.responsibility_key
     * @param applId The application_id of TYPE
     *                       fnd_responsibility_tl.application_id.
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The responsibility_name of TYPE
     *           fnd_responsibility_tl.responsibility_name%TYPE
     *
     * @throws UNKNOWN_RESPONSIBILITY when the responsibility name can not be
     *                                found based on a combination of
     *                                responsibility key and application id.
     *
     */
    public String getRespNameKey(
        DAOServices services,
        String respKey,
        BigDecimal applId,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_name_key(:2,:3,:4); end;");
            stmt.setString(2,respKey);
            stmt.setBigDecimal(3,applId);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility name for a given responsibility key and
     * application name combination. If a responsibility can not be found
     * based on the provided inputs, then an exception will be raised.
     *
     *
     * @param respKey The responsibility key of TYPE
     *                         fnd_responsibility.responsibility_key
     * @param applName The application_name of TYPE
     *                          fnd_application_tl.application_name.
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The responsibility_name of TYPE
     *           fnd_responsibility_tl.responsibility_name%TYPE
     *
     * @throws UNKNOWN_RESPONSIBILITY when the responsibility name can not be
     *                                found based on a combination of
     *                                responsibility key and application id.
     *
     */
    public String getRespNameKey(
        DAOServices services,
        String respKey,
        String applName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_name_key(:2,:3,:4); end;");
            stmt.setString(2,respKey);
            stmt.setString(3,applName);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility key for a given responsibility id and
     * application id. If the responsibility can not be located with the
     * provided inputs, then an exception will be raised.
     *
     *
     * @param respId The responsibility id of TYPE
     *                       fnd_responsibility_tl.responsibility_id
     *
     * @param applId The application_id of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @return The responsibility_key of TYPE
     *           fnd_responsibility.responsibility_key%TYPE
     *
     * @throws UNKNOWN_RESPONSIBILITY when the responsibility key can not be
     *                                found based on a combination of
     *                                responsibility id and application id.
     *
     */
    public String getRespKeyId(
        DAOServices services,
        BigDecimal respId,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_key_id(:2,:3); end;");
            stmt.setBigDecimal(2,respId);
            stmt.setBigDecimal(3,applId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility key for a given responsibility name,
     * application_id of the responsibility
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY')
     * if the given responsibility name does not exists.
     *
     * @param respName The responsibility name of TYPE
     *                          fnd_responsibility_tl.responsibility_name
     *
     * @param applId The application_id of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The responsibility_key of TYPE
     *           fnd_responsibility.responsibility_key%TYPE
     *
     **/
    public String getRespKeyName(
        DAOServices services,
        String respName,
        BigDecimal applId,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_key_name(:2,:3,:4); end;");
            stmt.setString(2,respName);
            stmt.setBigDecimal(3,applId);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility key for a given responsibility name,
     * application name of the responsibility
     * and language code(language code defaults to 'US' if NULL is specified).
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY')
     * if the given responsibility name does not exists.
     *
     * @param respName The responsibility name of TYPE
     *                          fnd_responsibility_tl.responsibility_name
     *
     * @param applName The application_name of TYPE
     *                          fnd_application_tl.application_name.
     *
     * @param language    The language_code of TYPE FND_LANGUAGES.LANGUAGE_CODE,
     *                     defaults to 'US' If NULL value is passed
     *
     * @return The responsibility_key of TYPE
     *           fnd_responsibility.responsibility_key%TYPE
     *
     **/
    public String getRespKeyName(
        DAOServices services,
        String respName,
        String applName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_key_name(:2,:3,:4); end;");
            stmt.setString(2,respName);
            stmt.setString(3,applName);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Returns a responsibility id for a given responsibility key,
     * application_id of the responsibility.
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY')
     * if the given responsibility name does not exists.
     *
     * @param respKey The responsibility key of TYPE
     *                         fnd_responsibility.responsibility_key
     *
     * @param applId The application_id of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @return The responsibility_id of TYPE
     *           fnd_responsibility.responsibility_id%TYPE
     *
     **/
    public BigDecimal getRespIdKey(
        DAOServices services,
        String respKey,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_id_key(:2,:3); end;");
            stmt.setString(2,respKey);
            stmt.setBigDecimal(3,applId);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Checks if a given user_id is assigned a given responsibility_id or not.
     * Returns FND_API.TRUE if responsibility is assigned to the user.
     * Else if the responsibility is not assigned to the given user_id,
     * it returns FND_API.FALSE.
     *
     * @param userId The user_id of TYPE fnd_user.user_id%TYPE.
     *
     * @param respId The responsibility id of TYPE
     *                       FND_RESPONSIBILITY.responsibility_id%TYPE
     *
     * @param applId The application id for the responsibility of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @return FND_API.TRUE if responsibility is assigned, else FND_API.FALSE
     *
     **/
    public String checkUserResp(
        DAOServices services,
        BigDecimal userId,
        BigDecimal respId,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_resp(:2,:3,:4); end;");
            stmt.setBigDecimal(2,userId);
            stmt.setBigDecimal(3,respId);
            stmt.setBigDecimal(4,applId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Determines if a user is assigned to a specific
     * responsibility/application combination. If they are then
     * FND_API.G_TRUE is returned, else FND_API.G_FALSE.
     *
     *
     * @param userName the login name of the user being checked
     * @param respKey the resp key of the responsibility being checked
     * @param applSname the application short name linked to the
     *                       responsibility
     *
     * @return FND_API.G_TRUE if found, else FND_API.G_FALSE
     *
     * @throws N/A
     *
     */
    public String checkUserResp(
        DAOServices services,
        String userName,
        String respKey,
        String applSname)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_resp(:2,:3,:4); end;");
            stmt.setString(2,userName);
            stmt.setString(3,respKey);
            stmt.setString(4,applSname);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns a list of application_id, responsibility_id and
     * responsibility names for a given user name .
     * This function does not check if the user is end dated.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_USER'),
     * if the user does not exist.
     *
     * @param userId The user_id of TYPE fnd_user.user_id%TYPE.
     * @param applicationId The application_id of TYPE
     *                                   fnd_application.application_id%TYPE.
     *                                   Defaults to NULL (ie Optional)
     *
     * @return responsibility_refcur
     **/
    public OracleResultSet getUserRespList(
        DAOServices services,
        BigDecimal userId,
        BigDecimal applicationId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_resp_list(:2,:3); end;");
            stmt.setBigDecimal(2,userId);
            stmt.setBigDecimal(3,applicationId);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns a list of application_id, responsibility_id and
     * responsibility names for a given user id.
     * This function does not check if the user is end dated.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_USER'),
     * if the user does not exist.
     *
     * @param userName The user_name of TYPE fnd_user.user_name%TYPE.
     * @param applicationName The application_name of TYPE
     *                                     fnd_application_tl.application_name%TYPE.
     *                                   Defaults to NULL (ie Optional)
     *
     * @param listRespRefcur The refcursor of type
     *                                   XXCCS_CAAM_APPL_PUB.p_list_resp_refcur
     *
     * @return p_list_resp_refcur.
     *
     **/
    public OracleResultSet getUserRespList(
        DAOServices services,
        String userName,
        String applicationName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_resp_list(:2,:3); end;");
            stmt.setString(2,userName);
            stmt.setString(3,applicationName);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns a list of application_id, function_id, function_names
     * and user_function_names for a given responsibility id.
     * Raises exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY')
     * if responsibility does not exist.
     *
     * @param    respId - fnd_responsibility.responsibility_id%type
     *
     * @param    applId - fnd_responsibility.application_id%type
     *
     * @return function_refcur
     *
     **/
    public OracleResultSet getRespFuncList(
        DAOServices services,
        BigDecimal respId,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_func_list(:2,:3); end;");
            stmt.setBigDecimal(2,respId);
            stmt.setBigDecimal(3,applId);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a given responsibility id exists.
     * Returns FND_API.TRUE if responsibility exists, else returns FND_API.G_FALSE
     *
     * @param respId The responsibility id of TYPE
     *                       FND_RESPONSIBILITY.responsibility_id%TYPE
     *
     * @param applId The application id for the responsibility of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @return FND_API.TRUE if responsibility exists, else FND_API.FALSE
     *
     **/
    public String checkRespId(
        DAOServices services,
        BigDecimal respId,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_resp_id(:2,:3); end;");
            stmt.setBigDecimal(2,respId);
            stmt.setBigDecimal(3,applId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns the top menu id attached to a given responsibility id,
     * application id.
     * Returns l_menu_id of type fnd_menus.menu_id%type;
     *
     * @param respId The responsibility id of TYPE
     *                       FND_RESPONSIBILITY.responsibility%TYPE
     *
     * @param applId The application id for the responsibility of TYPE
     *                       fnd_responsibility_tl.application_id.
     *
     * @return l_menu_id The menu id of type fnd_menus.menu_id%type;
     *
     **/
    public BigDecimal getTopMenuId(
        DAOServices services,
        BigDecimal respId,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_top_menu_id(:2,:3); end;");
            stmt.setBigDecimal(2,respId);
            stmt.setBigDecimal(3,applId);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns the menu id for a given user menu name.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_MENU'),
     * if the MENU does not exist.
     *
     * @param userMenuName The user menu name of type
     *                                 fnd_menus_tl.user_menu_name%type.
     *
     * @return l_menu_id The menu id of type fnd_responsibility.menu_id%type;
     *
     **/
    public BigDecimal getMenuIdName(
        DAOServices services,
        String userMenuName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_menu_id_name(:2); end;");
            stmt.setString(2,userMenuName);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a function or menu is excluded from a responsibility
     * and returns FND_API.G_TRUE if the given menu id or function id is excluded.
     *
     * @param respId The responsibility id of TYPE
     *                       FND_RESPONSIBILITY.responsibility_id%TYPE.
     *
     * @param respApplId The responsibilty application id of TYPE
     *                              FND_RESPONSIBILITY.application_id%TYPE.
     *
     * @param actionId The menu or function id of type
     *                          fnd_menus.menu_id%type or
     *                          fnd_form_functions.function_id%type.
     *
     * @param ruleType The rule type. For menus p_rule_type_i='M',
     *                          for functions p_rule_type_i='F'.
     *
     * @return FND_API.G_TRUE is the action id is excluded, else FND_API.G_FALSE
     *
     **/
    public String checkExclusion(
        DAOServices services,
        BigDecimal respId,
        BigDecimal respApplId,
        BigDecimal actionId,
        String ruleType)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_exclusion(:2,:3,:4,:5); end;");
            stmt.setBigDecimal(2,respId);
            stmt.setBigDecimal(3,respApplId);
            stmt.setBigDecimal(4,actionId);
            stmt.setString(5,ruleType);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function gets the function id given a user function name and language
     * (default 'US').
     * Raises Exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_FUNCTION'),
     * if the function does not exist.
     *
     * @param userFunctionName The user function name of type
     *                                      FND_FORM_FUNCTIONS_TL.user_function_name%TYPE.
     *
     * @param language The language of type FND_FORM_FUNCTIONS_TL.language%TYPE
     *                   default value is 'US'.
     *
     * @return l_function_id The function id of type
     *                              FND_FORM_FUNCTIONS_TL.function_id%type.
     *
     **/
    public BigDecimal getFuncIdUname(
        DAOServices services,
        String userFunctionName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_func_id_uname(:2,:3); end;");
            stmt.setString(2,userFunctionName);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns the data group id for a given data group name and
     * data group application id.
     * Raises Exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_DATA_GROUP'),
     * when data group does not exist.
     *
     * @param dataGrpName The data group name of type
     *                               fnd_data_groups.data_group_name%type.
     *
     * @param dataGrpAppId The application id for the data group of type
     *                                  fnd_data_group_units.application_id%type.
     *
     * @return l_data_grp_id The data group id of type
     *                              fnd_data_groups.data_group_id %type.
     *
     **/
    public BigDecimal getDataGrpIdName(
        DAOServices services,
        String dataGrpName,
        BigDecimal dataGrpApplId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_data_grp_id_name(:2,:3); end;");
            stmt.setString(2,dataGrpName);
            stmt.setBigDecimal(3,dataGrpApplId);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns the request group id for a given request group name
     * and request group application id.
     * Raises Exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_REQUEST_GROUP'),
     * when data group does not exist.
     *
     * @param reqGrpName The request group name of type
     *                              fnd_request_groups.request_group_name%type.
     *
     * @param reqGrpAppId The application id for the request group of type
     *                                 fnd_request_groups.application_id%type.
     *
     * @return l_req_grp_id The request group id of type
     *                             fnd_request_groups.request_group_id %type.
     *
     **/
    public BigDecimal getReqGrpIdName(
        DAOServices services,
        String reqGrpName,
        BigDecimal reqGrpApplId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_req_grp_id_name(:2,:3); end;");
            stmt.setString(2,reqGrpName);
            stmt.setBigDecimal(3,reqGrpApplId);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns the security group id, given the security group key.
     * Raises Exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_SECURITY_GROUP'),
     * when security group does not exist.
     *
     * @param secGrpKey The Security group key of type
     *                             fnd_security_groups.security_group_key%type
     *
     * @return L_sec_grp_id The Security group id of type
     *                             fnd_security_groups.security_group_id %type;
     *
     **/
    public BigDecimal getSecGrpIdKey(
        DAOServices services,
        String secGrpKey)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_sec_grp_id_key(:2); end;");
            stmt.setString(2,secGrpKey);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a responsibility name exists.
     * Returns FND_API.G_TRUE or FND_API.G_FALSE.
     * Does not check if the responsibility is end dated.
     *
     * @param respName The responsibility_name of type
     *                          fnd_responsibility_tl.responsibility_key%type
     *
     * @param applId The application id of type
     *                       fnd_responsibility_tl.application_id%type
     *
     * @param language    Language of type fnd_responsibility_tl.language%type
     *
     * @return FND_API.G_TRUE if responsibility name exists, else FND_API.G_FALSE
     *
     **/
    public String checkRespNameExists(
        DAOServices services,
        String respName,
        BigDecimal applId,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_resp_name_exists(:2,:3,:4); end;");
            stmt.setString(2,respName);
            stmt.setBigDecimal(3,applId);
            stmt.setString(4,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a responsibility key exists.
     * Returns FND_API.G_TRUE or FND_API.G_FALSE.
     * Does not check if the responsibility is end dated.
     *
     * @param respKey The responsibility_key of type
     *                         fnd_responsibility.responsibility_key%type
     *
     * @param applId The application id of type
     *                       fnd_responsibility.application_id%type
     *
     * @return FND_API.G_TRUE if responsibility key exists, else FND_API.G_FALSE
     *
     **/
    public String checkRespKeyExists(
        DAOServices services,
        String respKey,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_resp_key_exists(:2,:3); end;");
            stmt.setString(2,respKey);
            stmt.setBigDecimal(3,applId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns a list of organization_id, organization_name and
     * organization_code for a given responsibility id. This function does not
     * check if the responsibility is disabled.
     * Raises Exception XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_RESPONSIBILITY'),
     * if the responsibility does not exist.
     *
     * @param respId The responsibility id of TYPE
     *                       FND_RESPONSIBILITY.responsibility_id%TYPE
     *
     * @param applId The application id for the responsibility of TYPE
     *                       fnd_responsibility.application_id.
     *
     * @return inventory_orgs_refcur
     *
     *
     **/
    public OracleResultSet getRespInvOrgsList(
        DAOServices services,
        BigDecimal respId,
        BigDecimal applId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_resp_inv_orgs_list(:2,:3); end;");
            stmt.setBigDecimal(2,respId);
            stmt.setBigDecimal(3,applId);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Provides the ability to lookup the name of a role based on the
     * user viewable name of the role.
     *
     *
     * @param roleDescription the user viewable role name
     * @param language    Language of type fnd_responsibility_tl.language%type
     *
     * @return the internal role name (business key)
     *
     * @throws UNKNOWN_ROLE if role name is not found.
     * @throws NONUNIQUE_ROLE_NAME if multiple roles found with same name.
     *
     */
    public String getRoleNameByDesc(
        DAOServices services,
        String roleDescription,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_role_name_by_desc(:2,:3); end;");
            stmt.setString(2,roleDescription);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function will return the principal id for a given role name.
     * This function accepts the role name and returns the corresponding
     * principal id.
     * Raises exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_ROLE')
     * if no such role exists.
     *
     * @param  roleName - jtf_auth_principal_b.principal_name%type
     *
     * @return l_principal_id of jtf_auth_principal_b.jtf_auth_principal_id%type -
     *                               For a VALID role name.
     *
     **/
    public BigDecimal getPrincipalIdRole(
        DAOServices services,
        String roleName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_principal_id_role(:2); end;");
            stmt.setString(2,roleName);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a role name exists.
     * Returns FND_API.G_TRUE if role exists, else returns FND_API.G_FALSE.
     *
     * @param roleName The role name of type
     *                          jtf_auth_principals_b.principal_name%type.
     *
     * @return FND_API.G_TRUE if role name exists, else returns FND_API.G_FALSE.
     *
     **/
    public String checkRoleExists(
        DAOServices services,
        String roleName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_role_exists(:2); end;");
            stmt.setString(2,roleName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a role is assigned to any user.
     * Return FND_API.G_TRUE if the role is assigned, else returns FND_API.G_FALSE.
     *
     * @param roleId The role id (jtf_auth_principal_id) of type
     *                       jtf_auth_principal_maps.jtf_auth_parent_principal_id%type
     *
     * @return FND_API.G_TRUE or FND_API.G_FALSE
     *
     **/
    public String checkRoleAssigned(
        DAOServices services,
        BigDecimal roleId)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_role_assigned(:2); end;");
            stmt.setBigDecimal(2,roleId);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a given user has a particular permission.
     * Wrapper on JTF_AUTH_SECURITY_PKG.Check_permission
     * This function does not check if the user is end dated.
     * Returns FND_API.G_TRUE if the permission is assigned to the user,
     * else return FND_API.G_FALSE
     *
     * @param userName The user name of type fnd_user.user_name%type
     *
     * @param permName The permission name of type
     *                          jtf_auth_permissions_b.permission_name%type
     *
     * @return FND_API.G_TRUE or FND_API.G_FALSE
     *
     **/
    public String checkUserPermission(
        DAOServices services,
        String userName,
        String permName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_permission(:2,:3); end;");
            stmt.setString(2,userName);
            stmt.setString(3,permName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a given user has a particular role attached.
     * This function does not check if the user is end dated.
     * Returns FND_API.G_TRUE if the role is assigned to the user, else return
     * FND_API.G_FALSE
     *
     * @param userName The user name of type fnd_user.user_name%type
     *
     * @param roleName The role name of type
     *                          jtf_auth_permissions_b.permission_name%type
     *
     * @return FND_API.G_TRUE or FND_API.G_FALSE
     *
     **/
    public String checkUserRole(
        DAOServices services,
        String userName,
        String roleName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_user_role(:2,:3); end;");
            stmt.setString(2,userName);
            stmt.setString(3,roleName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function will return the principal id for a given user name.
     * Raises Exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_USER'),
     * if user does not exist.
     *
     * @param userName The user name of type
     *                          jtf_auth_principals_b.principal_name%type
     *
     * @return l_principal_id User principal id of type
     *                               jtf_auth_principals_b.jtf_auth_principal_id%type
     *
     **/
    public BigDecimal getPrincipalIdUser(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_principal_id_user(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function will return the list of role id, application id,
     * role name attached to a given user name.
     * This function does not check if the user is end dated(disbled).
     * Raises Exception using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_USER'),
     * if user does not exist
     *
     * @param userName The user name of type fnd_user.user_name%type.
     * @param language    Language of type fnd_responsibility_tl.language%type
     *
     * @return role_refcur
     *
     *
     **/
    public OracleResultSet getUserRoleList(
        DAOServices services,
        String userName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_role_list(:2,:3); end;");
            stmt.setString(2,userName);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns the list of permission id and permission name
     * assigned to a user.
     * It does not check if the user is end dated
     * Raises Excpetion using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_USER')
     *
     * @param userName The user name of type fnd_user.user_name%type
     * @param language    Language of type fnd_responsibility_tl.language%type
     *
     * @return permission_refcur
     *
     **/
    public OracleResultSet getUserPermissionList(
        DAOServices services,
        String userName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_permission_list(:2,:3); end;");
            stmt.setString(2,userName);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function returns the list of permission id and permission name
     * assigned to a role.
     * Raises Excpetion using XXCCS_FEA_UTL_EXCEPTION.THROW('UNKNOWN_ROLE')
     *
     * @param roleName The role name of type
     *                          jtf_auth_principals_b.principal_name%type
     * @param language    Language of type fnd_responsibility_tl.language%type
     *
     * @return  permission_refcur
     *
     **/
    public OracleResultSet getRolePermissionList(
        DAOServices services,
        String roleName,
        String language)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_role_permission_list(:2,:3); end;");
            stmt.setString(2,roleName);
            stmt.setString(3,language);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This function checks if a given permission name exists.
     * Returns FND_API.G_TRUE if the given permission name exists, else returns
     * FND_API.G_FALSE.
     *
     * @param permName The permission name of type
     *                          JTF_AUTH_PERMISSIONS_B.permission_name%type.
     *
     * @return FND_API.G_TRUE or FND_API.G_FALSE
     *
     **/
    public String checkPermissionExists(
        DAOServices services,
        String permName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.check_permission_exists(:2); end;");
            stmt.setString(2,permName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * This Function queries the FND_USER Extension table and returns the values
     * as a REFCUR of type XXCCS_CAAM_APPL_PUB.user_ext_refcur
     * Accepts user_name and returns REFCUR
     *
     * @param  userName username of type FND_USER.USER_NAME%TYPE
     *
     * @return user_ext_refcur
     *
     **/
    public OracleResultSet getExtTableValues(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_ext_table_values(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.CURSOR);
            stmt.execute();
            OracleResultSet retval=null;
            retval=(OracleResultSet)stmt.getObject(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }


    public BigDecimal getUserAccessLevel(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_access_level(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.NUMBER);
            stmt.execute();
            BigDecimal retval=null;
            retval=(BigDecimal)stmt.getBigDecimal(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }


    public void getAllRoles(
        DAOServices services,
        String userName,
        java.util.List[] roleTable)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin apps.xxccs_caam_appl_pub.get_all_roles(:1,:2); end;");
            stmt.setString(1,userName);
            stmt.registerOutParameter(2, OracleTypes.ARRAY,"APPS.XXCCS_CAAM_FUNCACCESS_TAB_TYPE");
            stmt.execute();
            ARRAY roleTableArray=(ARRAY)stmt.getArray(2);              
            roleTable[0]=buildListFromOracleArray(services.getNativeConnection(conn),roleTable[0],roleTableArray,(com.cisco.mcm.genJava.XxccsCaamFuncaccessObjType)null);

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }


    public void getAllaccessAllresp(
        DAOServices services,
        String userName,
        String responsibility,
        String applicationShortName,
        String primaryRoleProfile,
        java.util.List[] functionTable)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin apps.xxccs_caam_appl_pub.get_allaccess_allresp(:1,:2,:3,:4,:5); end;");
            stmt.setString(1,userName);
            stmt.setString(2,responsibility);
            stmt.setString(3,applicationShortName);
            stmt.setString(4,primaryRoleProfile);
            stmt.registerOutParameter(5, OracleTypes.ARRAY,"APPS.XXCCS_CAAM_FUNCACCESS_TAB_TYPE");
            stmt.execute();
            ARRAY functionTableArray=(ARRAY)stmt.getArray(5);
            functionTable[0]=buildListFromOracleArray(services.getNativeConnection(conn),functionTable[0],functionTableArray,(com.cisco.mcm.genJava.XxccsCaamFuncaccessObjType)null);

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }


    public void getListofUsers(
        DAOServices services,
        String applicationShortName,
        java.util.List[] userList)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin apps.xxccs_caam_appl_pub.get_listof_users(:1,:2); end;");
            stmt.setString(1,applicationShortName);
            stmt.registerOutParameter(2, OracleTypes.ARRAY,"APPS.XXCCS_CAAM_USERLIST_TAB_TYPE");
            stmt.execute();
            ARRAY userListArray=(ARRAY)stmt.getArray(2);                      
            userList[0]=buildListFromOracleArray(services.getNativeConnection(conn),userList[0],userListArray,(com.cisco.mcm.genJava.XxccsCaamUserlistObjType)null);

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }


    public void getUserAttributes(
        DAOServices services,
        String userName,
        java.util.List[] userAttributes)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin apps.xxccs_caam_appl_pub.get_user_attributes(:1,:2); end;");
            stmt.setString(1,userName);
           // stmt.setArray(2,buildOracleArrayFromList(services.getNativeConnection(conn),userAttributes[0],(com.cisco.servicesales.cm.dao.genJava.XxccsCaamUserAttrObjType)null));
            stmt.registerOutParameter(2, OracleTypes.ARRAY,"APPS.XXCCS_CAAM_USER_ATTR_TAB_TYPE");
            stmt.execute();
            ARRAY userAttributesArray=(ARRAY)stmt.getArray(2);                        
            userAttributes[0]=buildListFromOracleArray(services.getNativeConnection(conn),userAttributes[0],userAttributesArray,(com.cisco.mcm.genJava.XxccsCaamUserAttrObjType)null);

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }


    public String getUserType(
        DAOServices services,
        String userName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_user_type(:2); end;");
            stmt.setString(2,userName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }

    /**
     * Provides the ability to convert from a user name in the CEC namespace to
     * a user name in the CCO namespace.
     *
     * Only internal employees will have a user name in the CEC namespace,
     * therefore NULL will be returned when we are unable to find the
     * corresponding match.
     *
     *
     * @param cecUserName the user name from the CEC namespace.
     *
     * @return the user name from the CCO namespace (NULL if no match)
     *
     * @throws NULL_MANDATORY_PARAMETER
     *
     */
    public String getCcoForCecUser(
        DAOServices services,
        String cecUserName)
        throws SQLException,InstantiationException,IllegalAccessException {
        Connection conn=null;
        CallableStatement stmt=null;
        try {
            conn = services.borrowConnection();
            stmt = conn.prepareCall("begin :1 := apps.xxccs_caam_appl_pub.get_cco_for_cec_user(:2); end;");
            stmt.setString(2,cecUserName);
            stmt.registerOutParameter(1, OracleTypes.VARCHAR);
            stmt.execute();
            String retval=null;
            retval=(String)stmt.getString(1);
            return retval;

        } finally  {
            try {
                ConnectionUtil.closeQuietly(stmt);
            } finally {
                services.returnConnection(conn);
            }
        }
    }


    
/* BEGIN PROTECT_BLOCK user_java_code */
/* END PROTECT_BLOCK user_java_code */

}
